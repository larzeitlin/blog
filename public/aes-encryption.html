<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LZ</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type= "text/css" href="./styles.css"><link rel="icon"
       href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ‘»</text></svg>"><header>
| <a href="./">home</a>
| <a href="#top">top</a>
|  <a href="https://github.com/larzeitlin">github</a>
| ðŸ‘»
</header>
</head>
<body>
<div id="content" class="content">
<h1 class="title">LZ</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8e18d98">Advanced Encryption Standard in Clojure</a>
<ul>
<li><a href="#org1504b7f">Overview</a>
<ul>
<li><a href="#orgaebd94d">Processing per round (except first and last)</a></li>
</ul>
</li>
<li><a href="#org7956913">Key Expansion</a>
<ul>
<li><a href="#org751473e">s-box</a></li>
</ul>
</li>
<li><a href="#org1b26ed9">Round Constants</a></li>
<li><a href="#orge278cb9">Encryption Process</a></li>
<li><a href="#org078120a">Shift Rows</a></li>
<li><a href="#orgff46125">Mix Columns</a></li>
<li><a href="#org419089f">Galois Fields</a></li>
<li><a href="#org3f53cca">Polynomial addition</a></li>
<li><a href="#orge9457c1">Mix Columns continued</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org8e18d98" class="outline-2">
<h2 id="org8e18d98">Advanced Encryption Standard in Clojure</h2>
<div class="outline-text-2" id="text-org8e18d98">
<p>
The Advanced Encryption Standard (a.k.a Rijndael) is a widely used encryption specification. To learn how it works, and some of the motivation behind the design, I decided to build it in Clojure.
</p>

<blockquote>
<p>
WARNING!! Obviously don't use any of this code, or your own implementation of the AES, in production. It will be less efficient and less secure than using the standard libraries for your language of choice. This is just for educational perposes only.
</p>
</blockquote>
</div>

<div id="outline-container-org1504b7f" class="outline-3">
<h3 id="org1504b7f">Overview</h3>
<div class="outline-text-3" id="text-org1504b7f">
<p>
We're looking at AES-128 in ECB mode. 128 is the key size in bits. ECB (electronic codebook) simply means that each block (16 bytes) of our plaintext will be encrypted statelessly and independently of each other block. It is simpler and less secure than other modes.
Each block is processed with a number of steps including 11 rounds. Something a little different happens in the first and last rounds. Each round needs its own 16-byte key, but since we only have one 16-byte key to start with, we'll use it to generate more.
As you've probably noticed, everything is happening in chunks of 16 bytes. When it comes to encrypting blocks, we might as well think about them as being in a 4x4 grid in column-major order (ie. the grid is filled from top to bottom, left to right).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">5</td>
<td class="org-right">9</td>
<td class="org-right">13</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">6</td>
<td class="org-right">10</td>
<td class="org-right">14</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">7</td>
<td class="org-right">11</td>
<td class="org-right">15</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">12</td>
<td class="org-right">16</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgaebd94d" class="outline-4">
<h4 id="orgaebd94d">Processing per round (except first and last)</h4>
<div class="outline-text-4" id="text-orgaebd94d">
<ol class="org-ol">
<li>Replace each byte with another from a fixed lookup-table</li>
<li>Shift rows</li>
<li>Mix columns</li>
<li>XOR with the round-key</li>
</ol>

<p>
Thatâ€™s pretty much it. Weâ€™ll deal with the details when they come. Letâ€™s dive in.
</p>
</div>
</div>
</div>

<div id="outline-container-org7956913" class="outline-3">
<h3 id="org7956913">Key Expansion</h3>
<div class="outline-text-3" id="text-org7956913">
<p>
We need to make more keys. The 128-bit key is broken up into 4 32-bit words. These will be used to make a total of 44 words (4 for each of our 11 rounds). words w(0) to w(3) are just the original first 4 words. From there on each new word w(n) is made by XOR-ing w(n - 4) with w(n - 1), except every 4th word, where we use something different. Letâ€™s call this something t.
</p>


<div id="org20260e1" class="figure">
<p><img src="images/key-expansion.png" alt="key-expansion.png" />
</p>
</div>

<p>
We calculate t by rotating the previous word, switching the bytes with different bytes from a lookup table which weâ€™ll call s-box, and then XOR-ing this with a round-constant, which is a set value depending on the round. There is some mathematics behind the s-box, and weâ€™ll also use it again in a later part of this journey, but for now all that matters is that each possible byte can be looked up and will return a different byte, so we can just do this with a Clojure map. Weâ€™ll just use integers to represent them. Here you go:
</p>
</div>


<div id="outline-container-org751473e" class="outline-4">
<h4 id="org751473e">s-box</h4>
<div class="outline-text-4" id="text-org751473e">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">def</span> <span style="color: #00d3d0;">s-box</span> 
  <span style="color: #ff62d4;">{</span>0 99 249 153 121 182 65 131 70 90 218 87 62 178 74 214 164 73 186
   244 233 30 188 101 240 140 110 159 130 19 128 205 210 181 229 217
   153 238 213 3 7 197 59 226 86 177 154 184 20 250 224 225 72 82 58
   128 205 189 60 235 175 121 27 175 1 124 69 110 101 77 24 173 102 
   51 135 23 55 154 206 139 165 6 85 252 225 248 39 204 88 106 217 53
   46 49 149 42 239 223 157 94 4 242 204 75 77 227 106 2 197 166 232
   155 119 245 222 29 95 207 144 96 176 231 192 186 54 5 92 74 221 193
   141 93 137 167 234 135 104 69 15 118 48 4 242 137 50 35 251 15 116
   146 75 179 159 219 99 251 21 89 31 192 113 163 32 183 136 196 139
   61 174 228 208 112 182 78 214 246 193 120 241 161 226 152 235 233
   40 52 129 12 91 57 117 157 172 145 108 80 156 222 223 158 181 213
   56 7 33 253 13 215 22 71 168 194 90 190 237 85 109 60 216 97 191 
   8 143 115 178 55 247 104 167 92 36 54 41 165 187 234 195 46 118 
   56 150 144 238 40 196 28 162 58 184 108 219 185 89 203 100 67 243
   13 131 236 122 218 43 241 231 148 61 39 29 164 151 136 44 113 250
   45 93 76 6 111 111 168 28 156 134 68 64 9 189 122 198 180 155 20 
   248 65 227 17 220 134 103 133 170 172 51 195 25 212 201 221 166 36
   34 147 252 176 146 79 228 105 125 255 148 34 17 130 3 123 12 254 
   152 70 2 119 66 44 236 206 142 25 107 127 23 240 230 142 47 21 180
   141 158 11 35 38 127 210 82 0 76 41 215 14 97 239 19 125 57 18 202
   116 68 27 200 232 11 43 115 143 255 22 9 1 145 129 5 107 244 191 
   112 81 179 109 245 230 254 187 83 237 138 126 14 171 45 216 53 150
   78 47 132 95 26 162 123 33 203 31 140 100 16 202 133 151 163 10 81
   209 120 188 79 132 211 102 38 247 173 149 126 243 98 170 124 16 
   171 98 87 91 169 211 160 224 30 114 207 138 194 37 73 59 96 208 
   10 103 18 201 105 249 185 86 52 24 114 64 253 84 209 62 147 220 
   67 26 161 50 71 160 42 229 80 83 199 198 37 63 183 169 63 117 212
   72 94 88 8 48 246 66 190 174 177 200 49 199 84 32<span style="color: #ff62d4;">}</span><span style="color: #ffffff;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1b26ed9" class="outline-3">
<h3 id="org1b26ed9">Round Constants</h3>
<div class="outline-text-3" id="text-org1b26ed9">
<p>
The round constants are 4-byte words, the 3 least-significant-bytes are 0, and the most-significant byte comes from a list at the index determined by the round number. here is this list:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">def</span> <span style="color: #00d3d0;">round-constants</span>
 <span style="color: #ff62d4;">(</span>map #<span style="color: #3fdfd0;">(</span>vector <span style="color: #00d3d0;">%</span> 0 0 0<span style="color: #3fdfd0;">)</span> <span style="color: #3fdfd0;">[</span>1 2 4 8 16 32 64 128 27 54<span style="color: #3fdfd0;">]</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>
</pre>
</div>

<p>
With the above bits of data we can do the key expansion like so:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">forth-words-temp</span> <span style="color: #ff62d4;">[</span>prev counter<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #3fdfd0;">[</span>rotated <span style="color: #fba849;">(</span>take 4 <span style="color: #9f80ff;">(</span>drop 1 <span style="color: #4fe42f;">(</span>cycle prev<span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span>
        round-key <span style="color: #fba849;">(</span>nth round-key <span style="color: #9f80ff;">(</span>dec <span style="color: #4fe42f;">(</span>/ counter 4<span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span><span style="color: #3fdfd0;">]</span>
     <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> rotated
         <span style="color: #fba849;">(</span>map s-box<span style="color: #fba849;">)</span>
         <span style="color: #fba849;">(</span>map bit-xor round-key<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>

<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">next-word</span> <span style="color: #ff62d4;">[</span>words-so-far counter<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #3fdfd0;">[</span>prev <span style="color: #fba849;">(</span>last words-so-far<span style="color: #fba849;">)</span>
        n-minus-4th <span style="color: #fba849;">(</span>nth words-so-far <span style="color: #9f80ff;">(</span>- counter 4<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span>
        temp <span style="color: #fba849;">(</span><span style="color: #b6a0ff;">if</span> <span style="color: #9f80ff;">(</span>zero? <span style="color: #4fe42f;">(</span>mod counter 4<span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">)</span>
               <span style="color: #9f80ff;">(</span>forth-words-temp prev counter<span style="color: #9f80ff;">)</span>
               <span style="color: #9f80ff;">(</span>last words-so-far<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span><span style="color: #3fdfd0;">]</span>
    <span style="color: #3fdfd0;">(</span>map bit-xor n-minus-4th temp<span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>

<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">key-expansion</span> <span style="color: #ff62d4;">[</span>key<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span>
    <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #fba849;">[</span>input-key-words <span style="color: #9f80ff;">(</span>vec <span style="color: #4fe42f;">(</span>partition 4 key<span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">)</span><span style="color: #fba849;">]</span>
      <span style="color: #fba849;">(</span><span style="color: #b6a0ff;">loop</span> <span style="color: #9f80ff;">[</span>output-words input-key-words
             counter 4<span style="color: #9f80ff;">]</span>
        <span style="color: #9f80ff;">(</span><span style="color: #b6a0ff;">if</span>
          <span style="color: #4fe42f;">(</span>&lt; counter 44<span style="color: #4fe42f;">)</span>
          <span style="color: #4fe42f;">(</span><span style="color: #b6a0ff;">recur</span> <span style="color: #fe6060;">(</span>conj output-words
                       <span style="color: #4fafff;">(</span>next-word output-words counter<span style="color: #4fafff;">)</span><span style="color: #fe6060;">)</span>
                 <span style="color: #fe6060;">(</span>inc counter<span style="color: #fe6060;">)</span><span style="color: #4fe42f;">)</span>
          <span style="color: #a8a8a8; font-style: italic;">; else</span>
          output-words<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span>
    flatten
    <span style="color: #3fdfd0;">(</span>partition 16<span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-orge278cb9" class="outline-3">
<h3 id="orge278cb9">Encryption Process</h3>
<div class="outline-text-3" id="text-orge278cb9">
<p>
Now we have 11 keys we can get on with the work of encrypting a block. round 0 uses the first key and just consists of a simple XOR. 1 to 9 are as described above, and the final round is the same as those except there is no Mix Columns stage. Why? Because the whole point of Mix Columns is to diffuse, meaning to jumble up the information. If it were used in the final round, it would be trivially reversible, so it has no value.
</p>


<div id="org4bd35b9" class="figure">
<p><img src="images/encrypt-flow.png" alt="encrypt-flow.png" />
</p>
</div>

<p>
Weâ€™ve already looked at the S-box (yes, itâ€™s the same one), so letâ€™s see how Shift Rows works:
</p>
</div>
</div>

<div id="outline-container-org078120a" class="outline-3">
<h3 id="org078120a">Shift Rows</h3>
<div class="outline-text-3" id="text-org078120a">
<p>
Each row gets cycled to the left by a set number of steps. Easy.
</p>


<div id="org0f916b4" class="figure">
<p><img src="images/shift-rows.png" alt="shift-rows.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">shift-row</span> <span style="color: #ff62d4;">[</span>idx row<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> row cycle <span style="color: #3fdfd0;">(</span>drop idx<span style="color: #3fdfd0;">)</span> <span style="color: #3fdfd0;">(</span>take 4<span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>

<span style="color: #65737e; font-style: italic;">; </span><span style="color: #a8a8a8; font-style: italic;">we have to do this (apply map vector) malarkey </span>
<span style="color: #65737e; font-style: italic;">; </span><span style="color: #a8a8a8; font-style: italic;">because we are in column-major order</span>
<span style="color: #65737e; font-style: italic;">; </span><span style="color: #a8a8a8; font-style: italic;">and we want to get at the rows.</span>

<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">shift-rows</span> <span style="color: #ff62d4;">[</span>block<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> block
       <span style="color: #3fdfd0;">(</span>partition 4<span style="color: #3fdfd0;">)</span>
       <span style="color: #3fdfd0;">(</span>apply map vector<span style="color: #3fdfd0;">)</span>
       <span style="color: #3fdfd0;">(</span>map-indexed shift-row<span style="color: #3fdfd0;">)</span>
       <span style="color: #3fdfd0;">(</span>apply map vector<span style="color: #3fdfd0;">)</span>
       flatten<span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgff46125" class="outline-3">
<h3 id="orgff46125">Mix Columns</h3>
<div class="outline-text-3" id="text-orgff46125">
<p>
Bit more tricky. The main idea is a matrix-vector multiplication, like so:
</p>


<div id="org55a8a9c" class="figure">
<p><img src="images/mix-columns.png" alt="mix-columns.png" />
</p>
</div>

<p>
This looks simple enough. If you need a refresher on matrix-vector multiplication then <a href="https://www.khanacademy.org/math/linear-algebra/vectors-and-spaces/null-column-space/v/matrix-vector-products">this will do</a>.
</p>

<p>
However, there is a catch. we need to keep each element within the range of 1 byte. How to do that? we do the additions as XORs and the multiplications within Finite Field 256. Here we make a major detourâ€¦
</p>
</div>
</div>

<div id="outline-container-org419089f" class="outline-3">
<h3 id="org419089f">Galois Fields</h3>
<div class="outline-text-3" id="text-org419089f">
<p>
Now Iâ€™ll make all the mathematicians wince with some loose speak. A Finite Field, also called Galois Field, is a field with a finite number of elements. A field, in casual terms, is a set of numbers with some rules that allow us to do addition, subtraction, multiplication, and division without ever leaving that set of numbers. Galois Fields exist where the number of elements equals a prime to the power of some positive integer. We are interested in GF(2<sup>8</sup>) a.k.a GF(256). In order to multiply in this field, we need to remember polynomial maths and write some code that does polynomial arithmetic.
</p>


<p>
<a href="https://en.wikipedia.org/wiki/Finite_field_arithmetic#Rijndael's_(AES)_finite_field">https://en.wikipedia.org/wiki/Finite_field_arithmetic#Rijndael's_(AES)_finite_field</a>
</p>
<blockquote>
<p>
Disclaimer! this is not the most efficient way to do these calculations. I think itâ€™s better to write something understandable first, and then optimise later, rather than transcribing some <a href="https://en.wikipedia.org/wiki/Finite_field_arithmetic#Rijndael's_(AES)_finite_field">bit-shifting magic</a> and not getting it.
</p>
</blockquote>

<p>
We need to be able to do add, multiply, and divide. (donâ€™t worry about subtraction, we can just negate one of the operands to get that for free). To do all of this, we are going to think about numbers in GF(2<sup>8</sup>) as polynomials. These polynomials represent binary arrays where the coefficients are the numbers {1, 0} and the exponents are the positions of each bit in a byte.
</p>

<p>
For example, the number 74 can be represented in binary as:
</p>

<pre class="example">
[0 1 0 0 1 0 1 0]
</pre>

<p>
As a polynomial, where x = 2:
</p>


<div id="orgb574a90" class="figure">
<p><img src="images/binary-poly.png" alt="binary-poly.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org3f53cca" class="outline-3">
<h3 id="org3f53cca">Polynomial addition</h3>
<div class="outline-text-3" id="text-org3f53cca">
<p>
Weâ€™ll use vectors to represent polynomials just like the binary array above.
</p>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">padding</span> <span style="color: #ff62d4;">[</span>x len<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">-&gt;</span> <span style="color: #3fdfd0;">(</span>take <span style="color: #fba849;">(</span>- len <span style="color: #9f80ff;">(</span>count x<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span> <span style="color: #fba849;">(</span>repeat 0<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span>
      <span style="color: #3fdfd0;">(</span>concat x<span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>

<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">add</span> <span style="color: #ff62d4;">[</span>a b<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #3fdfd0;">[</span>max-length <span style="color: #fba849;">(</span>max <span style="color: #9f80ff;">(</span>count a<span style="color: #9f80ff;">)</span> <span style="color: #9f80ff;">(</span>count b<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span><span style="color: #3fdfd0;">]</span>
    <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> <span style="color: #fba849;">(</span>map + <span style="color: #9f80ff;">(</span>padding a max-length<span style="color: #9f80ff;">)</span>
                <span style="color: #9f80ff;">(</span>padding b max-length<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span>
         <span style="color: #fba849;">(</span>drop-while zero?<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>



<span style="color: #ffffff;">(</span>add <span style="color: #ff62d4;">[</span>1 0 1 0<span style="color: #ff62d4;">]</span> <span style="color: #ff62d4;">[</span>1<span style="color: #ff62d4;">]</span><span style="color: #ffffff;">)</span>
<span style="color: #65737e; font-style: italic;">; </span><span style="color: #a8a8a8; font-style: italic;">=&gt; (1 0 1 1)</span>

</pre>
</div>


<p>
Hey, that looks a lot like XOR! and if we were to throw a mod 2 on the end of it then it would be, since addition in our finite field is mod 2, weâ€™ll just use bit-xor later on in our matrix-multiplication.
</p>

<p>
Multiplication, you may remember from school, involved multiplying each element with every other element. I like to think about it in a grid.
</p>

<p>
For example: 
</p>

<pre class="example">
[1 0 1 1] [0 0 1 0] = [1 0 1 1 0]
</pre>


<div id="org2c27a41" class="figure">
<p><img src="images/bit-multip.png" alt="bit-multip.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">mult</span> <span style="color: #ff62d4;">[</span>a b<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #3fdfd0;">[</span>max-length <span style="color: #fba849;">(</span>max <span style="color: #9f80ff;">(</span>count a<span style="color: #9f80ff;">)</span> <span style="color: #9f80ff;">(</span>count b<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span>
        a' <span style="color: #fba849;">(</span><span style="color: #b6a0ff;">-&gt;</span> <span style="color: #9f80ff;">(</span>padding a max-length<span style="color: #9f80ff;">)</span> reverse vec<span style="color: #fba849;">)</span>
        b' <span style="color: #fba849;">(</span><span style="color: #b6a0ff;">-&gt;</span> <span style="color: #9f80ff;">(</span>padding b max-length<span style="color: #9f80ff;">)</span> reverse vec<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">]</span>
    <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> <span style="color: #fba849;">(</span><span style="color: #b6a0ff;">for</span> <span style="color: #9f80ff;">[</span>i <span style="color: #4fe42f;">(</span>range max-length<span style="color: #4fe42f;">)</span>
               j <span style="color: #4fe42f;">(</span>range max-length<span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">]</span>
           <span style="color: #9f80ff;">{</span><span style="color: #4fe42f;">(</span>+ i j<span style="color: #4fe42f;">)</span> <span style="color: #4fe42f;">(</span>* <span style="color: #fe6060;">(</span>a' i<span style="color: #fe6060;">)</span> <span style="color: #fe6060;">(</span>b' j<span style="color: #fe6060;">)</span><span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">}</span><span style="color: #fba849;">)</span>
         <span style="color: #fba849;">(</span>apply merge-with +<span style="color: #fba849;">)</span>
         <span style="color: #fba849;">(</span>sort-by key &gt;<span style="color: #fba849;">)</span>
         <span style="color: #fba849;">(</span>map second<span style="color: #fba849;">)</span>
         <span style="color: #fba849;">(</span>drop-while zero?<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>
</pre>
</div>


<p>
Finally, division. This is good old long-division. You sort the polynomials into order with the biggest exponent first. See how many times the most significant element of the denominator goes into the most significant element of the numerator. Put that ratio down in your result, multiply the denominator by that ratio, subtract that multiplication from the numerator (youâ€™ve just eliminated the most significant element of the numerator). Repeat until you canâ€™t eliminate any more, adding up the results as you go. Hereâ€™s some code:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">&gt;poly</span> 
  <span style="color: #b0d6f5; font-style: italic;">"test if a is greater than b"</span>
  <span style="color: #ff62d4;">[</span>a b<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #3fdfd0;">[</span>a' <span style="color: #fba849;">(</span>drop-while zero? a<span style="color: #fba849;">)</span>
        b' <span style="color: #fba849;">(</span>drop-while zero? b<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">]</span>
    <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">cond</span>
      <span style="color: #fba849;">(</span>= a' b'<span style="color: #fba849;">)</span> <span style="color: #00bcff;">false</span>
      <span style="color: #fba849;">(</span>&gt; <span style="color: #9f80ff;">(</span>count a'<span style="color: #9f80ff;">)</span> <span style="color: #9f80ff;">(</span>count b'<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span> <span style="color: #00bcff;">true</span>
      <span style="color: #fba849;">(</span>&lt; <span style="color: #9f80ff;">(</span>count a'<span style="color: #9f80ff;">)</span> <span style="color: #9f80ff;">(</span>count b'<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span> <span style="color: #00bcff;">false</span>
      <span style="color: #fba849;">(</span>empty? <span style="color: #9f80ff;">(</span>drop-while #<span style="color: #4fe42f;">(</span>&gt;= 0 <span style="color: #00d3d0;">%</span><span style="color: #4fe42f;">)</span> <span style="color: #4fe42f;">(</span>map - a' b'<span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span> <span style="color: #00bcff;">false</span>
      <span style="color: #00bcff;">:else</span> <span style="color: #00bcff;">true</span><span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>


<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">div</span>
  <span style="color: #b0d6f5; font-style: italic;">"returns a vector of ratio and remainder"</span>
  <span style="color: #ff62d4;">[</span>n d<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">cond</span> <span style="color: #3fdfd0;">(</span>= n d<span style="color: #3fdfd0;">)</span> <span style="color: #3fdfd0;">[</span><span style="color: #fba849;">[</span>1<span style="color: #fba849;">]</span> <span style="color: #fba849;">[</span>0<span style="color: #fba849;">]</span><span style="color: #3fdfd0;">]</span>
        <span style="color: #3fdfd0;">(</span>&gt;poly d n<span style="color: #3fdfd0;">)</span> <span style="color: #3fdfd0;">[</span><span style="color: #fba849;">[</span>0<span style="color: #fba849;">]</span> n<span style="color: #3fdfd0;">]</span>
        <span style="color: #00bcff;">:else</span>
        <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">loop</span> <span style="color: #fba849;">[</span>remain n
               res <span style="color: #9f80ff;">[]</span><span style="color: #fba849;">]</span>
          <span style="color: #fba849;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #9f80ff;">[</span>new-exp <span style="color: #4fe42f;">(</span>- <span style="color: #fe6060;">(</span>count remain<span style="color: #fe6060;">)</span> <span style="color: #fe6060;">(</span>count d<span style="color: #fe6060;">)</span><span style="color: #4fe42f;">)</span>
                new-coef <span style="color: #4fe42f;">(</span>/ <span style="color: #fe6060;">(</span>first remain<span style="color: #fe6060;">)</span> <span style="color: #fe6060;">(</span>first d<span style="color: #fe6060;">)</span><span style="color: #4fe42f;">)</span>
                new-res-element <span style="color: #4fe42f;">(</span>cons new-coef <span style="color: #fe6060;">(</span>take new-exp <span style="color: #4fafff;">(</span>repeat 0<span style="color: #4fafff;">)</span><span style="color: #fe6060;">)</span><span style="color: #4fe42f;">)</span>
                new-remain <span style="color: #4fe42f;">(</span>add remain <span style="color: #fe6060;">(</span>map - <span style="color: #4fafff;">(</span>mult d new-res-element<span style="color: #4fafff;">)</span><span style="color: #fe6060;">)</span><span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">]</span>
            <span style="color: #9f80ff;">(</span><span style="color: #b6a0ff;">if</span> <span style="color: #4fe42f;">(</span>&lt; new-exp 0<span style="color: #4fe42f;">)</span>
              <span style="color: #4fe42f;">[</span>res new-remain<span style="color: #4fe42f;">]</span>
              <span style="color: #4fe42f;">(</span><span style="color: #b6a0ff;">recur</span> new-remain
                     <span style="color: #fe6060;">(</span>add res new-res-element<span style="color: #fe6060;">)</span><span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>
</pre>
</div>

<p>
Now we have the bits we need for multiplication in GF(2<sup>8</sup>). Galois field multiplication works with modulo, to prevent us from leaving the set, but the divisor of the modulo is itself a polynomial. This has to be an <a href="https://en.wikipedia.org/wiki/Irreducible_polynomial">irreducible polynomial</a>. For the AES algorithm, we use the binary representation of 283, which is [1 0 0 0 1 1 0 1 1]. Our division function above gives us a remainder, so we can use it for modulus. If the result of our multiplication is big enough to hit the 9th bitâ€¦
</p>

<p>
&gt; [1 1 1 1 1 1 1 1]
</p>

<p>
â€¦ then weâ€™ll divide by our divisor and take the remainder. Hereâ€™s how. Thereâ€™s some extra cruft to deal with switching between these vectors representing binary arrays and integers.
</p>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">int-&gt;bin-vec</span> <span style="color: #ff62d4;">[</span>x<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> x
       <span style="color: #6ae4b9;">Integer</span>/toBinaryString
       <span style="color: #3fdfd0;">(</span>map int<span style="color: #3fdfd0;">)</span>
       <span style="color: #3fdfd0;">(</span>map #<span style="color: #fba849;">(</span>- <span style="color: #00d3d0;">%</span> 48<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span>
       vec<span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>

<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">gf-256-mult</span> <span style="color: #ff62d4;">[</span>a b ip<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #3fdfd0;">[</span>poly-prod <span style="color: #fba849;">(</span>mult <span style="color: #9f80ff;">(</span>int-&gt;bin-vec a<span style="color: #9f80ff;">)</span> <span style="color: #9f80ff;">(</span>int-&gt;bin-vec b<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span>
        <span style="color: #fba849;">[</span>_ poly-mod<span style="color: #fba849;">]</span> <span style="color: #fba849;">(</span>div poly-prod <span style="color: #9f80ff;">(</span>int-&gt;bin-vec ip<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span><span style="color: #3fdfd0;">]</span>
    <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> poly-mod
         <span style="color: #fba849;">(</span>map #<span style="color: #9f80ff;">(</span>mod <span style="color: #00d3d0;">%</span> 2<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span>
         reverse
         <span style="color: #fba849;">(</span>map-indexed <span style="color: #9f80ff;">(</span><span style="color: #b6a0ff;">fn</span> <span style="color: #4fe42f;">[</span>idx val<span style="color: #4fe42f;">]</span> <span style="color: #4fe42f;">(</span>* val <span style="color: #fe6060;">(</span><span style="color: #6ae4b9;">Math</span>/pow 2 idx<span style="color: #fe6060;">)</span><span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span>
         <span style="color: #fba849;">(</span>reduce +<span style="color: #fba849;">)</span>
         int<span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>
</pre>
</div>

<p>
â€¦phew! Okay, now we can finally do our finite field multiplications. Letâ€™s travel back up the stack to Mix Columns.
</p>
</div>
</div>

<div id="outline-container-orge9457c1" class="outline-3">
<h3 id="orge9457c1">Mix Columns continued</h3>
<div class="outline-text-3" id="text-orge9457c1">
<p>
So we had our matrix multiplication laid out above. Now we know how to multiply.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">def</span> <span style="color: #00d3d0;">column-mix-matrix</span>
  <span style="color: #ff62d4;">[</span><span style="color: #3fdfd0;">[</span>2 3 1 1<span style="color: #3fdfd0;">]</span>
   <span style="color: #3fdfd0;">[</span>1 2 3 1<span style="color: #3fdfd0;">]</span>
   <span style="color: #3fdfd0;">[</span>1 1 2 3<span style="color: #3fdfd0;">]</span>
   <span style="color: #3fdfd0;">[</span>3 1 1 2<span style="color: #3fdfd0;">]</span><span style="color: #ff62d4;">]</span><span style="color: #ffffff;">)</span>

<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">mix-column</span> <span style="color: #ff62d4;">[</span>matrix irr column<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">for</span> <span style="color: #3fdfd0;">[</span>row matrix<span style="color: #3fdfd0;">]</span>
    <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #fba849;">[</span>result <span style="color: #9f80ff;">(</span>apply bit-xor
                        <span style="color: #4fe42f;">(</span>map <span style="color: #6ae4b9;">gf</span>/gf-256-mult
                             row
                             column
                             <span style="color: #fe6060;">(</span>repeat irr<span style="color: #fe6060;">)</span><span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">)</span><span style="color: #fba849;">]</span>
      <span style="color: #fba849;">(</span><span style="color: #b6a0ff;">if</span> <span style="color: #9f80ff;">(</span>&gt; 0x100 result<span style="color: #9f80ff;">)</span>
        result
        <span style="color: #9f80ff;">(</span>bit-xor irr result<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>

<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">mix-columns</span> <span style="color: #ff62d4;">[</span>block<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> block
       <span style="color: #3fdfd0;">(</span>partition 4<span style="color: #3fdfd0;">)</span>
       <span style="color: #3fdfd0;">(</span>map <span style="color: #fba849;">(</span>partial mix-column column-mix-matrix 0x11b<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span>
       flatten<span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>

</pre>
</div>

<p>
Thatâ€™s it. We can just tie it all together with a few orchestrating functions. Before doing so letâ€™s just refresh our memory as to what the whole process should look like.
</p>


<div id="org0e7f5e5" class="figure">
<p><img src="images/encrypt-flow.png" alt="encrypt-flow.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">normal-round</span> <span style="color: #ff62d4;">[</span>round-key block<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> block
       <span style="color: #3fdfd0;">(</span>map s-box<span style="color: #3fdfd0;">)</span>
       shift-rows
       mix-columns
       <span style="color: #3fdfd0;">(</span>map bit-xor round-key<span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>

<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">apply-normal-rounds</span> <span style="color: #ff62d4;">[</span>split-keys block<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">loop</span> <span style="color: #3fdfd0;">[</span>b block
         r-keys split-keys
         n 1<span style="color: #3fdfd0;">]</span>
    <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #fba849;">[</span><span style="color: #9f80ff;">[</span>round-key &amp; other-keys<span style="color: #9f80ff;">]</span> r-keys<span style="color: #fba849;">]</span>
      <span style="color: #fba849;">(</span><span style="color: #b6a0ff;">if</span> <span style="color: #9f80ff;">(</span>&lt; n 10<span style="color: #9f80ff;">)</span>
        <span style="color: #9f80ff;">(</span><span style="color: #b6a0ff;">recur</span> <span style="color: #4fe42f;">(</span>normal-round round-key b<span style="color: #4fe42f;">)</span>
               other-keys
               <span style="color: #4fe42f;">(</span>inc n<span style="color: #4fe42f;">)</span><span style="color: #9f80ff;">)</span>
        b<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>

<span style="color: #ffffff;">(</span><span style="color: #b6a0ff;">defn</span> <span style="color: #feacd0;">aes-128-encrypt-block</span> <span style="color: #ff62d4;">[</span>key block<span style="color: #ff62d4;">]</span>
  <span style="color: #ff62d4;">(</span><span style="color: #b6a0ff;">let</span> <span style="color: #3fdfd0;">[</span>split-keys <span style="color: #fba849;">(</span>key-expansion key<span style="color: #fba849;">)</span><span style="color: #3fdfd0;">]</span>
    <span style="color: #3fdfd0;">(</span><span style="color: #b6a0ff;">-&gt;&gt;</span> block
         <span style="color: #fba849;">(</span>map bit-xor <span style="color: #9f80ff;">(</span>first split-keys<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span>
         <span style="color: #fba849;">(</span>apply-normal-rounds <span style="color: #9f80ff;">(</span>rest split-keys<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span>
         <span style="color: #fba849;">(</span>map s-box<span style="color: #fba849;">)</span>
         shift-rows
         <span style="color: #fba849;">(</span>map bit-xor <span style="color: #9f80ff;">(</span>last split-keys<span style="color: #9f80ff;">)</span><span style="color: #fba849;">)</span><span style="color: #3fdfd0;">)</span><span style="color: #ff62d4;">)</span><span style="color: #ffffff;">)</span>
</pre>
</div>

<p>
Boom. Happy encrypting. Decryption is pretty straight forward, by the way, Iâ€™ll let you figure that out for yourself.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
