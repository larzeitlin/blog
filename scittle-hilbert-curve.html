<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LZ</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
</head>
<body>
<div id="content">
<h1 class="title">LZ</h1>
<p>
<a href="./index.html">home</a>
</p>

<script src="https://cdn.jsdelivr.net/npm/scittle@0.5.14/dist/scittle.js"
        type="application/javascript"></script>
<script type="application/x-scittle">
  (defn my-alert []
   (js/alert "You clicked!"))
  ;; export function to use from JavaScript:
  (set! (.-my_alert js/window) my-alert)
</script>

<p>
Let's make a hilbert curve on is page in Clojure (the one 
&#10084) and allow the reader to manipulate the code in-place.
</p>

<div id="outline-container-orgc24778d" class="outline-2">
<h2 id="orgc24778d">what is a hilbert curve?</h2>
<div class="outline-text-2" id="text-orgc24778d">
<p>
A <a href="http://en.wikipedia.org/wiki/Hilbert_curve">Hibert Curve</a> is a space-filling fractal. it's useful for mapping 2 dimensional space stuff onto 1 dimension. I like it because it looks good.
</p>


<div class="figure">
<p><img src="images/HC-3-iterations.png" alt="HC-3-iterations.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org01e1d2e" class="outline-2">
<h2 id="org01e1d2e">what is scittle?</h2>
<div class="outline-text-2" id="text-org01e1d2e">
<p>
<a href="https://github.com/babashka/scittle">Scittle</a> is is a small Clojure interpreter designed to be embedded inside web pages using html <code>&lt;script&gt;</code> tags. For example to evaluate code input by the user.
</p>
</div>

<div id="outline-container-orgee96add" class="outline-3">
<h3 id="orgee96add">Aside</h3>
<div class="outline-text-3" id="text-orgee96add">
<p>
It's great how simple Scittle is to use inside this blog. I'm writing in an <a href="https://orgmode.org">org file</a> in Emacs. I embed some script tags in a <a href="https://orgmode.org/manual/Quoting-HTML-tags.html">export block</a>. Like so:
</p>

<div class="org-src-container">
<pre class="src src-org">#+begin_export html
&lt;script src="https://cdn.jsdelivr.net/npm/scittle@0.5.14/dist/scittle.js"
	type="application/javascript"&gt;&lt;/script&gt;
&lt;script type="application/x-scittle"&gt;
  (defn my-alert []
   (js/alert "You clicked!"))
  ;; export function to use from JavaScript:
  (set! (.-my_alert js/window) my-alert)
&lt;/script&gt;

&lt;body&gt;
  &lt;button onclick="my_alert()"&gt;
    Click me!
  &lt;/button&gt;
&lt;/body&gt;
#+end_export
</pre>
</div>

<body>
  <button onclick="my_alert()">
    Click me!
  </button>
</body>


<p>
Then I run my regular <a href="how-this-blog-works.html">build script</a> and away we go, running Clojure in my blog post via skittle via js via org-mode-export with practically no extra configuration at all. That's wild.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb247ad5" class="outline-2">
<h2 id="orgb247ad5">handle user input code</h2>
<div class="outline-text-2" id="text-orgb247ad5">
<p>
First let's make a <code>textarea</code> in html to get the user input. We'd like a button to click evaluate what the user enters. Then output the result beneath.
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;script type="application/x-scittle"&gt;

(defn set-output-area [v output-id]
  (-&gt; (js/document.getElementById output-id)
      (.-innerHTML)
      (set! v)))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-&gt; input-id
      js/document.getElementById 
      .-value
      try-eval))

(set! (.-read_input js/window)
      #(set-output-area (read-eval-input "code-area")
			"output-area"))

&lt;/script&gt;
&lt;body&gt;
&lt;textarea id="code-area"
	  style="font-family:monospace;"&gt;
(take 21 ((fn fib [a b] (lazy-seq (cons a (fib b (+ a b))))) 0 1))
&lt;/textarea&gt;
&lt;button onclick="read_input()"&gt;eval&lt;/button&gt;
&lt;p id="output-area"&gt;...&lt;/p&gt;
&lt;/body&gt;
</pre>
</div>

<script type="application/x-scittle">

(defn set-output-area [v output-id]
  (-> (js/document.getElementById output-id)
      (.-innerHTML)
      (set! v)))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-> input-id
      js/document.getElementById 
      .-value
      try-eval))

(set! (.-read_input js/window)
      #(set-output-area (read-eval-input "code-area")
                        "output-area"))
 
</script>
<body>
<textarea id="code-area"
          style="font-family:monospace;">
(take 21 ((fn fib [a b] (lazy-seq (cons a (fib b (+ a b))))) 0 1))
</textarea>
<button onclick="read_input()">eval</button>
<p id="output-area">...</p>
</body>

<p>
Right nice.
</p>
</div>
</div>

<div id="outline-container-org90e3dda" class="outline-2">
<h2 id="org90e3dda">drawing</h2>
<div class="outline-text-2" id="text-org90e3dda">
<p>
I think the easiest way to do this will be with <code>canvas</code>.
</p>


<div class="org-src-container">
<pre class="src src-html">&lt;canvas id="my-canvas" width="400" height="400"&gt;&lt;/canvas&gt;

&lt;script type="application/x-scittle"&gt;  
(def c (js/document.getElementById "my-canvas"))
(def ctx (.getContext c "2d"))

(.moveTo ctx 50 50)
(.lineTo ctx 50 150)
(.lineTo ctx 150 150)
(.lineTo ctx 150 50)
(.stroke ctx)
&lt;/script&gt;
</pre>
</div>



<canvas id="my-canvas" width="200" height="200"></canvas>

<script type="application/x-scittle">  
(def c (js/document.getElementById "my-canvas"))
(def ctx (.getContext c "2d"))

(.moveTo ctx 50 50)
(.lineTo ctx 50 150)
(.lineTo ctx 150 150)
(.lineTo ctx 150 50)
(.stroke ctx)
</script>

<p>
Let's have it so that the user can pass in an vector of points that the line will go through:
</p>

<div class="org-src-container">
<pre class="src src-html">&lt;canvas id="user-points-canvas" width="200" height="200"&gt;&lt;/canvas&gt;

&lt;script type="application/x-scittle"&gt;

(def c (js/document.getElementById "user-points-canvas"))
(def ctx (.getContext c "2d"))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-&gt; input-id
      js/document.getElementById 
      .-value
      try-eval))

(defn draw-line-from-points [context points]
  (.clearRect context 0 0 (.-width c) (.-height c))
  (.beginPath context)
  (.moveTo context (-&gt; points first first) (-&gt; points first second))
  (doseq [[x y] (rest points)]
    (.lineTo context x y))
  (.stroke context))

(set! (.-read_points js/window)
      #(-&gt;&gt; (read-eval-input "user-points-input")
	    (draw-line-from-points ctx)))

&lt;/script&gt;
&lt;body&gt;
&lt;textarea id="user-points-input"
	  style="font-family:monospace;"&gt;
[[50 50] [50 150] [150 150] [150 50]]
&lt;/textarea&gt;
&lt;button onclick="read_points()"&gt;Draw points&lt;/button&gt;
&lt;/body&gt;
</pre>
</div>

<canvas id="user-points-canvas" width="200" height="200"></canvas>

<script type="application/x-scittle">

(def c (js/document.getElementById "user-points-canvas"))
(def ctx (.getContext c "2d"))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-> input-id
      js/document.getElementById 
      .-value
      try-eval))

(defn draw-line-from-points [context points]
  (.clearRect context 0 0 (.-width c) (.-height c))
  (.beginPath context)
  (.moveTo context (-> points first first) (-> points first second))
  (doseq [[x y] (rest points)]
    (.lineTo context x y))
  (.stroke context))

(set! (.-read_points js/window)
      #(->> (read-eval-input "user-points-input")
            (draw-line-from-points ctx)))

</script>
<body>
<textarea id="user-points-input"
          style="font-family:monospace;">
[[50 50] [50 150] [150 150] [150 50]]
</textarea>
<button onclick="read_points()">Draw points</button>
</body>

<p>
Now it's just a matter of choosing the right points.
</p>
</div>
</div>

<div id="outline-container-org3f6dd83" class="outline-2">
<h2 id="org3f6dd83">making the hilbert curve</h2>
<div class="outline-text-2" id="text-org3f6dd83">
<p>
How this fractal works is that there are four patterns, and each one of these four pattern can be split up into quarters, and each one of those quarters can be swapped for one of the original four patterns. Recursion.
</p>

<p>
Here's the details of that mapping:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(def rules {:A {:path [[0 0] [0 1] [1 1] [1 0]]
		:next-iteration [:D :A :A :B]}
	    :B {:path [[1 1] [0 1] [0 0] [1 0]]
		:next-iteration [:C :B :B :A]}
	    :C {:path [[1 1] [1 0] [0 0] [0 1]]
		:next-iteration [:B :C :C :D]}
	    :D {:path [[0 0] [1 0] [1 1] [0 1]]
		:next-iteration [:A :D :D :C]}})
</pre>
</div>

<p>
So each path has four points we can think about it as tracing three sides of a square in a specific order. Let's say the origin is top-left, then the path for <code>:A</code> is from the origin, across the top, down the right side and from right to left across the bottom. The sides and the order we go through the points is all significant.
</p>

<p>
Let's think about our canvas as a square split up into square cells. The number of cells is controlled by the number of iterations we perform (4<sup>n</sup>). Each cell contains a pattern, we need to have the right order of cells and the right pattern for each. So we'll aim for a sequence of <code>cells</code>, where a <code>cell</code> is an [x, y] vector identifying the cell, and a pattern. Here's the zero'th iteration with a single cell in it:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(def init [{:cell [0 0] :pattern :A}])
</pre>
</div>

<p>
To turn this into the next iteration we need to subdivide the space into four cells, and then add a pattern for each one:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(defn -&gt;subcells
  [{:keys [cell pattern]}]
  (let [top-left-subcell (map (partial * 2) cell)
	path-step-&gt;subcells (fn [path-step]
			      (map + top-left-subcell
				     path-step)) 
	path (-&gt;&gt; rules
		  pattern
		  :path
		  (map path-step-&gt;subcells))
	cell-patterns (-&gt; rules pattern :next-iteration)]
    (map (fn [cell pattern]
	   {:cell cell :pattern pattern})
	 path
	 cell-patterns)))

(-&gt;subcells init)

;=&gt; ({:cell (0 0), :pattern :D}
;    {:cell (0 1), :pattern :A}
;    {:cell (1 1), :pattern :A}
;    {:cell (1 0), :pattern :B})
</pre>
</div>

<p>
Okay, now we would like to iterate that, each time concatenating the results into a single sequence. 
</p>

<div class="org-src-container">
<pre class="src src-clojure">(defn hilbert-curve-cells [iterations]
  (-&gt; (iterate #(-&gt;&gt; % (map -&gt;subcells) (apply concat)) init)
      (nth iterations)))

(hilbert-curve-cells 2)

;=&gt; ({:cell (0 0), :pattern :A}
;    {:cell (1 0), :pattern :D}
;    {:cell (1 1), :pattern :D}
;    {:cell (0 1), :pattern :C}
;    {:cell (0 2), :pattern :D}
;    {:cell (0 3), :pattern :A}
;    {:cell (1 3), :pattern :A}
;    {:cell (1 2), :pattern :B}
;    {:cell (2 2), :pattern :D}
;    {:cell (2 3), :pattern :A}
;    {:cell (3 3), :pattern :A}
;    {:cell (3 2), :pattern :B}
;    {:cell (3 1), :pattern :C}
;    {:cell (2 1), :pattern :B}
;    {:cell (2 0), :pattern :B}
;    {:cell (3 0), :pattern :A})
</pre>
</div>

<p>
Lovely. Okay we don't care about the patterns any more once we have finished iterating, but we do want to change from cells to points on the canvas. Let's grab the ordered cells and use the canvas dimensions to turn them into points.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(defn cells-&gt;points [cells iterations canvas-width]
  (let [width-in-cells (js/Math.pow 2 iterations)
	step-width (/ canvas-width width-in-cells)]
    (-&gt;&gt; cells
	 (map :cell)
	 (map #(map * 1% 2%) (repeat [step-width step-width])))))

(defn hilbert-curve-points [iterations canvas-width]
  (-&gt; (hilbert-curve-cells iterations)
      (cells-&gt;points iterations canvas-width)))

(hilbert-curve-points 2 400)

;=&gt; ((0.0 0.0)
;    (100.0 0.0)
;    (100.0 100.0)
;    (0.0 100.0)
;    (0.0 200.0)
;    (0.0 300.0)
;    (100.0 300.0)
;    (100.0 200.0)
;    (200.0 200.0)
;    (200.0 300.0)
;    (300.0 300.0)
;    (300.0 200.0)
;    (300.0 100.0)
;    (200.0 100.0)
;    (200.0 0.0)
;    (300.0 0.0))

</pre>
</div>

<canvas id="hilbert-canvas" width="600" height="600"></canvas>

<script type="application/x-scittle">

(def hc (js/document.getElementById "hilbert-canvas"))
(def hctx (.getContext hc "2d"))
(set! (.-lineWidth hctx 20))

(defn try-eval [v]
  (try (js/scittle.core.eval_string v)
    (catch js/Error e
      (str "ERROR: " e))))

(defn read-eval-input [input-id]
  (-> input-id
      js/document.getElementById 
      .-value
      try-eval))

(defn draw-line-from-points [context points]
  (.clearRect context 0 0 (.-width hc) (.-height hc))
  (.beginPath context)
  (.moveTo context (-> points first first) (-> points first second))
  (doseq [[x y] (rest points)]
    (.lineTo context x y))
  (.stroke context))

(set! (.-read_hilbert_points js/window)
      #(->> (read-eval-input "hilbert-input")
            (draw-line-from-points hctx)))

</script>
<body>
<textarea id="hilbert-input"
          rows="20"
          style="font-family:monospace;">
(def rules 
  {:A {:path [[0 0] [0 1] [1 1] [1 0]]
   :next-iteration [:D :A :A :B]}
   :B {:path [[1 1] [0 1] [0 0] [1 0]]
   :next-iteration [:C :B :B :A]}
   :C {:path [[1 1] [1 0] [0 0] [0 1]]
   :next-iteration [:B :C :C :D]}
   :D {:path [[0 0] [1 0] [1 1] [0 1]]
   :next-iteration [:A :D :D :C]}})
   
(def init [{:cell [0 0] :pattern :A}])

(defn ->subcells
  [{:keys [cell pattern]}]
  (let [top-left-subcell (map (partial * 2) cell)
        path-step->subcells (fn [path-step]
                              (map + top-left-subcell
                                     path-step)) 
        path (->> rules
                  pattern
                  :path
                  (map path-step->subcells))
        cell-patterns (-> rules pattern :next-iteration)]
    (map (fn [cell pattern]
           {:cell cell :pattern pattern})
         path
         cell-patterns)))

(defn hilbert-curve-cells [iterations]
  (-> (iterate #(->> % (map ->subcells) (apply concat)) init)
      (nth iterations)))

(defn cells->points [cells iterations canvas-width]
  (let [width-in-cells (js/Math.pow 2 iterations)
        step-width (/ canvas-width width-in-cells)]
    (->> cells
         (map :cell)
         (map #(map * %1 %2) (repeat [step-width step-width])))))

(defn hilbert-curve-points [iterations canvas-width]
  (-> (hilbert-curve-cells iterations)
      (cells->points iterations canvas-width)))

(hilbert-curve-points 6 600)

</textarea>
<button onclick="read_hilbert_points()">Draw points</button>
</body>

<p>
That's it. Muck about with the code and see what results you can get.
</p>
</div>
</div>
</div>
</body>
</html>
