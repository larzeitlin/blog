<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LZ</title>
<meta name="generator" content="Org Mode" />
<link rel ="stylesheet" type= "text/css" href="./styles.css"><link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ‘»</text></svg>">
</head>
<body>
<div id="content" class="content">
<h1 class="title">LZ</h1>
<p>
<a href="./index.html">home</a>
</p>

<div id="outline-container-orgbb46eb5" class="outline-2">
<h2 id="orgbb46eb5">Advanced Encryption Standard in Clojure</h2>
<div class="outline-text-2" id="text-orgbb46eb5">
<p>
The Advanced Encryption Standard (a.k.a Rijndael) is a widely used encryption specification. To learn how it works, and some of the motivation behind the design, I decided to build it in Clojure.
</p>

<blockquote>
<p>
WARNING!! Obviously don't use any of this code, or your own implementation of the AES, in production. It will be less efficient and less secure than using the standard libraries for your language of choice. This is just for educational perposes only.
</p>
</blockquote>
</div>

<div id="outline-container-orgcd3b920" class="outline-3">
<h3 id="orgcd3b920">Overview</h3>
<div class="outline-text-3" id="text-orgcd3b920">
<p>
We're looking at AES-128 in ECB mode. 128 is the key size in bits. ECB (electronic codebook) simply means that each block (16 bytes) of our plaintext will be encrypted statelessly and independently of each other block. It is simpler and less secure than other modes.
Each block is processed with a number of steps including 11 rounds. Something a little different happens in the first and last rounds. Each round needs its own 16-byte key, but since we only have one 16-byte key to start with, we'll use it to generate more.
As you've probably noticed, everything is happening in chunks of 16 bytes. When it comes to encrypting blocks, we might as well think about them as being in a 4x4 grid in column-major order (ie. the grid is filled from top to bottom, left to right).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">5</td>
<td class="org-right">9</td>
<td class="org-right">13</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">6</td>
<td class="org-right">10</td>
<td class="org-right">14</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">7</td>
<td class="org-right">11</td>
<td class="org-right">15</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">8</td>
<td class="org-right">12</td>
<td class="org-right">16</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org7de208b" class="outline-4">
<h4 id="org7de208b">Processing per round (except first and last)</h4>
<div class="outline-text-4" id="text-org7de208b">
<ol class="org-ol">
<li>Replace each byte with another from a fixed lookup-table</li>
<li>Shift rows</li>
<li>Mix columns</li>
<li>XOR with the round-key</li>
</ol>

<p>
Thatâ€™s pretty much it. Weâ€™ll deal with the details when they come. Letâ€™s dive in.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc7429bf" class="outline-3">
<h3 id="orgc7429bf">Key Expansion</h3>
<div class="outline-text-3" id="text-orgc7429bf">
<p>
We need to make more keys. The 128-bit key is broken up into 4 32-bit words. These will be used to make a total of 44 words (4 for each of our 11 rounds). words w(0) to w(3) are just the original first 4 words. From there on each new word w(n) is made by XOR-ing w(n - 4) with w(n - 1), except every 4th word, where we use something different. Letâ€™s call this something t.
</p>


<div id="org5acae09" class="figure">
<p><img src="images/key-expansion.png" alt="key-expansion.png" />
</p>
</div>

<p>
We calculate t by rotating the previous word, switching the bytes with different bytes from a lookup table which weâ€™ll call s-box, and then XOR-ing this with a round-constant, which is a set value depending on the round. There is some mathematics behind the s-box, and weâ€™ll also use it again in a later part of this journey, but for now all that matters is that each possible byte can be looked up and will return a different byte, so we can just do this with a Clojure map. Weâ€™ll just use integers to represent them. Here you go:
</p>
</div>


<div id="outline-container-orgf22eac1" class="outline-4">
<h4 id="orgf22eac1">s-box</h4>
<div class="outline-text-4" id="text-orgf22eac1">
<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">def</span> <span class="org-variable-name">s-box</span> 
  <span class="org-rainbow-delimiters-depth-2">{</span>0 99 249 153 121 182 65 131 70 90 218 87 62 178 74 214 164 73 186
   244 233 30 188 101 240 140 110 159 130 19 128 205 210 181 229 217
   153 238 213 3 7 197 59 226 86 177 154 184 20 250 224 225 72 82 58
   128 205 189 60 235 175 121 27 175 1 124 69 110 101 77 24 173 102 
   51 135 23 55 154 206 139 165 6 85 252 225 248 39 204 88 106 217 53
   46 49 149 42 239 223 157 94 4 242 204 75 77 227 106 2 197 166 232
   155 119 245 222 29 95 207 144 96 176 231 192 186 54 5 92 74 221 193
   141 93 137 167 234 135 104 69 15 118 48 4 242 137 50 35 251 15 116
   146 75 179 159 219 99 251 21 89 31 192 113 163 32 183 136 196 139
   61 174 228 208 112 182 78 214 246 193 120 241 161 226 152 235 233
   40 52 129 12 91 57 117 157 172 145 108 80 156 222 223 158 181 213
   56 7 33 253 13 215 22 71 168 194 90 190 237 85 109 60 216 97 191 
   8 143 115 178 55 247 104 167 92 36 54 41 165 187 234 195 46 118 
   56 150 144 238 40 196 28 162 58 184 108 219 185 89 203 100 67 243
   13 131 236 122 218 43 241 231 148 61 39 29 164 151 136 44 113 250
   45 93 76 6 111 111 168 28 156 134 68 64 9 189 122 198 180 155 20 
   248 65 227 17 220 134 103 133 170 172 51 195 25 212 201 221 166 36
   34 147 252 176 146 79 228 105 125 255 148 34 17 130 3 123 12 254 
   152 70 2 119 66 44 236 206 142 25 107 127 23 240 230 142 47 21 180
   141 158 11 35 38 127 210 82 0 76 41 215 14 97 239 19 125 57 18 202
   116 68 27 200 232 11 43 115 143 255 22 9 1 145 129 5 107 244 191 
   112 81 179 109 245 230 254 187 83 237 138 126 14 171 45 216 53 150
   78 47 132 95 26 162 123 33 203 31 140 100 16 202 133 151 163 10 81
   209 120 188 79 132 211 102 38 247 173 149 126 243 98 170 124 16 
   171 98 87 91 169 211 160 224 30 114 207 138 194 37 73 59 96 208 
   10 103 18 201 105 249 185 86 52 24 114 64 253 84 209 62 147 220 
   67 26 161 50 71 160 42 229 80 83 199 198 37 63 183 169 63 117 212
   72 94 88 8 48 246 66 190 174 177 200 49 199 84 32<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1100d97" class="outline-3">
<h3 id="org1100d97">Round Constants</h3>
<div class="outline-text-3" id="text-org1100d97">
<p>
The round constants are 4-byte words, the 3 least-significant-bytes are 0, and the most-significant byte comes from a list at the index determined by the round number. here is this list:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">def</span> <span class="org-variable-name">round-constants</span>
 <span class="org-rainbow-delimiters-depth-2">(</span>map #<span class="org-rainbow-delimiters-depth-3">(</span>vector <span class="org-variable-name">%</span> 0 0 0<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">[</span>1 2 4 8 16 32 64 128 27 54<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
With the above bits of data we can do the key expansion like so:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">forth-words-temp</span> <span class="org-rainbow-delimiters-depth-2">[</span>prev counter<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>rotated <span class="org-rainbow-delimiters-depth-4">(</span>take 4 <span class="org-rainbow-delimiters-depth-5">(</span>drop 1 <span class="org-rainbow-delimiters-depth-6">(</span>cycle prev<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
        round-key <span class="org-rainbow-delimiters-depth-4">(</span>nth round-key <span class="org-rainbow-delimiters-depth-5">(</span>dec <span class="org-rainbow-delimiters-depth-6">(</span>/ counter 4<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
     <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">-&gt;&gt;</span> rotated
         <span class="org-rainbow-delimiters-depth-4">(</span>map s-box<span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>map bit-xor round-key<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">next-word</span> <span class="org-rainbow-delimiters-depth-2">[</span>words-so-far counter<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>prev <span class="org-rainbow-delimiters-depth-4">(</span>last words-so-far<span class="org-rainbow-delimiters-depth-4">)</span>
        n-minus-4th <span class="org-rainbow-delimiters-depth-4">(</span>nth words-so-far <span class="org-rainbow-delimiters-depth-5">(</span>- counter 4<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
        temp <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-5">(</span>zero? <span class="org-rainbow-delimiters-depth-6">(</span>mod counter 4<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
               <span class="org-rainbow-delimiters-depth-5">(</span>forth-words-temp prev counter<span class="org-rainbow-delimiters-depth-5">)</span>
               <span class="org-rainbow-delimiters-depth-5">(</span>last words-so-far<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>map bit-xor n-minus-4th temp<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">key-expansion</span> <span class="org-rainbow-delimiters-depth-2">[</span>key<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;&gt;</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-4">[</span>input-key-words <span class="org-rainbow-delimiters-depth-5">(</span>vec <span class="org-rainbow-delimiters-depth-6">(</span>partition 4 key<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">]</span>
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">loop</span> <span class="org-rainbow-delimiters-depth-5">[</span>output-words input-key-words
             counter 4<span class="org-rainbow-delimiters-depth-5">]</span>
        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span>
          <span class="org-rainbow-delimiters-depth-6">(</span>&lt; counter 44<span class="org-rainbow-delimiters-depth-6">)</span>
          <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">recur</span> <span class="org-rainbow-delimiters-depth-7">(</span>conj output-words
                       <span class="org-rainbow-delimiters-depth-8">(</span>next-word output-words counter<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span>
                 <span class="org-rainbow-delimiters-depth-7">(</span>inc counter<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
          <span class="org-comment">; else</span>
          output-words<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    flatten
    <span class="org-rainbow-delimiters-depth-3">(</span>partition 16<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org3a9027c" class="outline-3">
<h3 id="org3a9027c">Encryption Process</h3>
<div class="outline-text-3" id="text-org3a9027c">
<p>
Now we have 11 keys we can get on with the work of encrypting a block. round 0 uses the first key and just consists of a simple XOR. 1 to 9 are as described above, and the final round is the same as those except there is no Mix Columns stage. Why? Because the whole point of Mix Columns is to diffuse, meaning to jumble up the information. If it were used in the final round, it would be trivially reversible, so it has no value.
</p>


<div id="org0e2557f" class="figure">
<p><img src="images/encrypt-flow.png" alt="encrypt-flow.png" />
</p>
</div>

<p>
Weâ€™ve already looked at the S-box (yes, itâ€™s the same one), so letâ€™s see how Shift Rows works:
</p>
</div>
</div>

<div id="outline-container-org66b861b" class="outline-3">
<h3 id="org66b861b">Shift Rows</h3>
<div class="outline-text-3" id="text-org66b861b">
<p>
Each row gets cycled to the left by a set number of steps. Easy.
</p>


<div id="org9d93afe" class="figure">
<p><img src="images/shift-rows.png" alt="shift-rows.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">shift-row</span> <span class="org-rainbow-delimiters-depth-2">[</span>idx row<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;&gt;</span> row cycle <span class="org-rainbow-delimiters-depth-3">(</span>drop idx<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">(</span>take 4<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-comment-delimiter">; </span><span class="org-comment">we have to do this (apply map vector) malarkey </span>
<span class="org-comment-delimiter">; </span><span class="org-comment">because we are in column-major order</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">and we want to get at the rows.</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">shift-rows</span> <span class="org-rainbow-delimiters-depth-2">[</span>block<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;&gt;</span> block
       <span class="org-rainbow-delimiters-depth-3">(</span>partition 4<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">(</span>apply map vector<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">(</span>map-indexed shift-row<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">(</span>apply map vector<span class="org-rainbow-delimiters-depth-3">)</span>
       flatten<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge453fe0" class="outline-3">
<h3 id="orge453fe0">Mix Columns</h3>
<div class="outline-text-3" id="text-orge453fe0">
<p>
Bit more tricky. The main idea is a matrix-vector multiplication, like so:
</p>


<div id="org7d31f89" class="figure">
<p><img src="images/mix-columns.png" alt="mix-columns.png" />
</p>
</div>

<p>
This looks simple enough. If you need a refresher on matrix-vector multiplication then <a href="https://www.khanacademy.org/math/linear-algebra/vectors-and-spaces/null-column-space/v/matrix-vector-products">this will do</a>.
</p>

<p>
However, there is a catch. we need to keep each element within the range of 1 byte. How to do that? we do the additions as XORs and the multiplications within Finite Field 256. Here we make a major detourâ€¦
</p>
</div>
</div>

<div id="outline-container-orga50c10d" class="outline-3">
<h3 id="orga50c10d">Galois Fields</h3>
<div class="outline-text-3" id="text-orga50c10d">
<p>
Now Iâ€™ll make all the mathematicians wince with some loose speak. A Finite Field, also called Galois Field, is a field with a finite number of elements. A field, in casual terms, is a set of numbers with some rules that allow us to do addition, subtraction, multiplication, and division without ever leaving that set of numbers. Galois Fields exist where the number of elements equals a prime to the power of some positive integer. We are interested in GF(2<sup>8</sup>) a.k.a GF(256). In order to multiply in this field, we need to remember polynomial maths and write some code that does polynomial arithmetic.
</p>


<p>
<a href="https://en.wikipedia.org/wiki/Finite_field_arithmetic#Rijndael's_(AES)_finite_field">https://en.wikipedia.org/wiki/Finite_field_arithmetic#Rijndael's_(AES)_finite_field</a>
</p>
<blockquote>
<p>
Disclaimer! this is not the most efficient way to do these calculations. I think itâ€™s better to write something understandable first, and then optimise later, rather than transcribing some <a href="https://en.wikipedia.org/wiki/Finite_field_arithmetic#Rijndael's_(AES)_finite_field">bit-shifting magic</a> and not getting it.
</p>
</blockquote>

<p>
We need to be able to do add, multiply, and divide. (donâ€™t worry about subtraction, we can just negate one of the operands to get that for free). To do all of this, we are going to think about numbers in GF(2<sup>8</sup>) as polynomials. These polynomials represent binary arrays where the coefficients are the numbers {1, 0} and the exponents are the positions of each bit in a byte.
</p>

<p>
For example, the number 74 can be represented in binary as:
</p>

<pre class="example">
[0 1 0 0 1 0 1 0]
</pre>

<p>
As a polynomial, where x = 2:
</p>


<div id="orgf6646d0" class="figure">
<p><img src="images/binary-poly.png" alt="binary-poly.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org19a54e0" class="outline-3">
<h3 id="org19a54e0">Polynomial addition</h3>
<div class="outline-text-3" id="text-org19a54e0">
<p>
Weâ€™ll use vectors to represent polynomials just like the binary array above.
</p>


<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">padding</span> <span class="org-rainbow-delimiters-depth-2">[</span>x len<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;</span> <span class="org-rainbow-delimiters-depth-3">(</span>take <span class="org-rainbow-delimiters-depth-4">(</span>- len <span class="org-rainbow-delimiters-depth-5">(</span>count x<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-rainbow-delimiters-depth-4">(</span>repeat 0<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>concat x<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">add</span> <span class="org-rainbow-delimiters-depth-2">[</span>a b<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>max-length <span class="org-rainbow-delimiters-depth-4">(</span>max <span class="org-rainbow-delimiters-depth-5">(</span>count a<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>count b<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">-&gt;&gt;</span> <span class="org-rainbow-delimiters-depth-4">(</span>map + <span class="org-rainbow-delimiters-depth-5">(</span>padding a max-length<span class="org-rainbow-delimiters-depth-5">)</span>
                <span class="org-rainbow-delimiters-depth-5">(</span>padding b max-length<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>drop-while zero?<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>



<span class="org-rainbow-delimiters-depth-1">(</span>add <span class="org-rainbow-delimiters-depth-2">[</span>1 0 1 0<span class="org-rainbow-delimiters-depth-2">]</span> <span class="org-rainbow-delimiters-depth-2">[</span>1<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">=&gt; (1 0 1 1)</span>

</pre>
</div>


<p>
Hey, that looks a lot like XOR! and if we were to throw a mod 2 on the end of it then it would be, since addition in our finite field is mod 2, weâ€™ll just use bit-xor later on in our matrix-multiplication.
</p>

<p>
Multiplication, you may remember from school, involved multiplying each element with every other element. I like to think about it in a grid.
</p>

<p>
For example: 
</p>

<pre class="example">
[1 0 1 1] [0 0 1 0] = [1 0 1 1 0]
</pre>


<div id="org672cd90" class="figure">
<p><img src="images/bit-multip.png" alt="bit-multip.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">mult</span> <span class="org-rainbow-delimiters-depth-2">[</span>a b<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>max-length <span class="org-rainbow-delimiters-depth-4">(</span>max <span class="org-rainbow-delimiters-depth-5">(</span>count a<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>count b<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
        a' <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">-&gt;</span> <span class="org-rainbow-delimiters-depth-5">(</span>padding a max-length<span class="org-rainbow-delimiters-depth-5">)</span> reverse vec<span class="org-rainbow-delimiters-depth-4">)</span>
        b' <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">-&gt;</span> <span class="org-rainbow-delimiters-depth-5">(</span>padding b max-length<span class="org-rainbow-delimiters-depth-5">)</span> reverse vec<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">-&gt;&gt;</span> <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-5">[</span>i <span class="org-rainbow-delimiters-depth-6">(</span>range max-length<span class="org-rainbow-delimiters-depth-6">)</span>
               j <span class="org-rainbow-delimiters-depth-6">(</span>range max-length<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">]</span>
           <span class="org-rainbow-delimiters-depth-5">{</span><span class="org-rainbow-delimiters-depth-6">(</span>+ i j<span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-6">(</span>* <span class="org-rainbow-delimiters-depth-7">(</span>a' i<span class="org-rainbow-delimiters-depth-7">)</span> <span class="org-rainbow-delimiters-depth-7">(</span>b' j<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">}</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>apply merge-with +<span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>sort-by key &gt;<span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>map second<span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>drop-while zero?<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>


<p>
Finally, division. This is good old long-division. You sort the polynomials into order with the biggest exponent first. See how many times the most significant element of the denominator goes into the most significant element of the numerator. Put that ratio down in your result, multiply the denominator by that ratio, subtract that multiplication from the numerator (youâ€™ve just eliminated the most significant element of the numerator). Repeat until you canâ€™t eliminate any more, adding up the results as you go. Hereâ€™s some code:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">&gt;poly</span> 
  <span class="org-doc">"test if a is greater than b"</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>a b<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>a' <span class="org-rainbow-delimiters-depth-4">(</span>drop-while zero? a<span class="org-rainbow-delimiters-depth-4">)</span>
        b' <span class="org-rainbow-delimiters-depth-4">(</span>drop-while zero? b<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">cond</span>
      <span class="org-rainbow-delimiters-depth-4">(</span>= a' b'<span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-constant">false</span>
      <span class="org-rainbow-delimiters-depth-4">(</span>&gt; <span class="org-rainbow-delimiters-depth-5">(</span>count a'<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>count b'<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-constant">true</span>
      <span class="org-rainbow-delimiters-depth-4">(</span>&lt; <span class="org-rainbow-delimiters-depth-5">(</span>count a'<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>count b'<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-constant">false</span>
      <span class="org-rainbow-delimiters-depth-4">(</span>empty? <span class="org-rainbow-delimiters-depth-5">(</span>drop-while #<span class="org-rainbow-delimiters-depth-6">(</span>&gt;= 0 <span class="org-variable-name">%</span><span class="org-rainbow-delimiters-depth-6">)</span> <span class="org-rainbow-delimiters-depth-6">(</span>map - a' b'<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span> <span class="org-constant">false</span>
      <span class="org-clojure-keyword">:else</span> <span class="org-constant">true</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>


<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">div</span>
  <span class="org-doc">"returns a vector of ratio and remainder"</span>
  <span class="org-rainbow-delimiters-depth-2">[</span>n d<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">cond</span> <span class="org-rainbow-delimiters-depth-3">(</span>= n d<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">]</span>
        <span class="org-rainbow-delimiters-depth-3">(</span>&gt;poly d n<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> n<span class="org-rainbow-delimiters-depth-3">]</span>
        <span class="org-clojure-keyword">:else</span>
        <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">loop</span> <span class="org-rainbow-delimiters-depth-4">[</span>remain n
               res <span class="org-rainbow-delimiters-depth-5">[]</span><span class="org-rainbow-delimiters-depth-4">]</span>
          <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-5">[</span>new-exp <span class="org-rainbow-delimiters-depth-6">(</span>- <span class="org-rainbow-delimiters-depth-7">(</span>count remain<span class="org-rainbow-delimiters-depth-7">)</span> <span class="org-rainbow-delimiters-depth-7">(</span>count d<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
                new-coef <span class="org-rainbow-delimiters-depth-6">(</span>/ <span class="org-rainbow-delimiters-depth-7">(</span>first remain<span class="org-rainbow-delimiters-depth-7">)</span> <span class="org-rainbow-delimiters-depth-7">(</span>first d<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
                new-res-element <span class="org-rainbow-delimiters-depth-6">(</span>cons new-coef <span class="org-rainbow-delimiters-depth-7">(</span>take new-exp <span class="org-rainbow-delimiters-depth-8">(</span>repeat 0<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span>
                new-remain <span class="org-rainbow-delimiters-depth-6">(</span>add remain <span class="org-rainbow-delimiters-depth-7">(</span>map - <span class="org-rainbow-delimiters-depth-8">(</span>mult d new-res-element<span class="org-rainbow-delimiters-depth-8">)</span><span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">]</span>
            <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-6">(</span>&lt; new-exp 0<span class="org-rainbow-delimiters-depth-6">)</span>
              <span class="org-rainbow-delimiters-depth-6">[</span>res new-remain<span class="org-rainbow-delimiters-depth-6">]</span>
              <span class="org-rainbow-delimiters-depth-6">(</span><span class="org-keyword">recur</span> new-remain
                     <span class="org-rainbow-delimiters-depth-7">(</span>add res new-res-element<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Now we have the bits we need for multiplication in GF(2<sup>8</sup>). Galois field multiplication works with modulo, to prevent us from leaving the set, but the divisor of the modulo is itself a polynomial. This has to be an <a href="https://en.wikipedia.org/wiki/Irreducible_polynomial">irreducible polynomial</a>. For the AES algorithm, we use the binary representation of 283, which is [1 0 0 0 1 1 0 1 1]. Our division function above gives us a remainder, so we can use it for modulus. If the result of our multiplication is big enough to hit the 9th bitâ€¦
</p>

<p>
&gt; [1 1 1 1 1 1 1 1]
</p>

<p>
â€¦ then weâ€™ll divide by our divisor and take the remainder. Hereâ€™s how. Thereâ€™s some extra cruft to deal with switching between these vectors representing binary arrays and integers.
</p>


<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">int-&gt;bin-vec</span> <span class="org-rainbow-delimiters-depth-2">[</span>x<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;&gt;</span> x
       <span class="org-type">Integer</span>/toBinaryString
       <span class="org-rainbow-delimiters-depth-3">(</span>map int<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">(</span>map #<span class="org-rainbow-delimiters-depth-4">(</span>- <span class="org-variable-name">%</span> 48<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
       vec<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">gf-256-mult</span> <span class="org-rainbow-delimiters-depth-2">[</span>a b ip<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>poly-prod <span class="org-rainbow-delimiters-depth-4">(</span>mult <span class="org-rainbow-delimiters-depth-5">(</span>int-&gt;bin-vec a<span class="org-rainbow-delimiters-depth-5">)</span> <span class="org-rainbow-delimiters-depth-5">(</span>int-&gt;bin-vec b<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
        <span class="org-rainbow-delimiters-depth-4">[</span>_ poly-mod<span class="org-rainbow-delimiters-depth-4">]</span> <span class="org-rainbow-delimiters-depth-4">(</span>div poly-prod <span class="org-rainbow-delimiters-depth-5">(</span>int-&gt;bin-vec ip<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">-&gt;&gt;</span> poly-mod
         <span class="org-rainbow-delimiters-depth-4">(</span>map #<span class="org-rainbow-delimiters-depth-5">(</span>mod <span class="org-variable-name">%</span> 2<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         reverse
         <span class="org-rainbow-delimiters-depth-4">(</span>map-indexed <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">fn</span> <span class="org-rainbow-delimiters-depth-6">[</span>idx val<span class="org-rainbow-delimiters-depth-6">]</span> <span class="org-rainbow-delimiters-depth-6">(</span>* val <span class="org-rainbow-delimiters-depth-7">(</span><span class="org-type">Math</span>/pow 2 idx<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>reduce +<span class="org-rainbow-delimiters-depth-4">)</span>
         int<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
â€¦phew! Okay, now we can finally do our finite field multiplications. Letâ€™s travel back up the stack to Mix Columns.
</p>
</div>
</div>

<div id="outline-container-org574bfff" class="outline-3">
<h3 id="org574bfff">Mix Columns continued</h3>
<div class="outline-text-3" id="text-org574bfff">
<p>
So we had our matrix multiplication laid out above. Now we know how to multiply.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">def</span> <span class="org-variable-name">column-mix-matrix</span>
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>2 3 1 1<span class="org-rainbow-delimiters-depth-3">]</span>
   <span class="org-rainbow-delimiters-depth-3">[</span>1 2 3 1<span class="org-rainbow-delimiters-depth-3">]</span>
   <span class="org-rainbow-delimiters-depth-3">[</span>1 1 2 3<span class="org-rainbow-delimiters-depth-3">]</span>
   <span class="org-rainbow-delimiters-depth-3">[</span>3 1 1 2<span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">mix-column</span> <span class="org-rainbow-delimiters-depth-2">[</span>matrix irr column<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-3">[</span>row matrix<span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-4">[</span>result <span class="org-rainbow-delimiters-depth-5">(</span>apply bit-xor
                        <span class="org-rainbow-delimiters-depth-6">(</span>map <span class="org-type">gf</span>/gf-256-mult
                             row
                             column
                             <span class="org-rainbow-delimiters-depth-7">(</span>repeat irr<span class="org-rainbow-delimiters-depth-7">)</span><span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">]</span>
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-5">(</span>&gt; 0x100 result<span class="org-rainbow-delimiters-depth-5">)</span>
        result
        <span class="org-rainbow-delimiters-depth-5">(</span>bit-xor irr result<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">mix-columns</span> <span class="org-rainbow-delimiters-depth-2">[</span>block<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;&gt;</span> block
       <span class="org-rainbow-delimiters-depth-3">(</span>partition 4<span class="org-rainbow-delimiters-depth-3">)</span>
       <span class="org-rainbow-delimiters-depth-3">(</span>map <span class="org-rainbow-delimiters-depth-4">(</span>partial mix-column column-mix-matrix 0x11b<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
       flatten<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

</pre>
</div>

<p>
Thatâ€™s it. We can just tie it all together with a few orchestrating functions. Before doing so letâ€™s just refresh our memory as to what the whole process should look like.
</p>


<div id="orge6babc8" class="figure">
<p><img src="images/encrypt-flow.png" alt="encrypt-flow.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-clojure"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">normal-round</span> <span class="org-rainbow-delimiters-depth-2">[</span>round-key block<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">-&gt;&gt;</span> block
       <span class="org-rainbow-delimiters-depth-3">(</span>map s-box<span class="org-rainbow-delimiters-depth-3">)</span>
       shift-rows
       mix-columns
       <span class="org-rainbow-delimiters-depth-3">(</span>map bit-xor round-key<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">apply-normal-rounds</span> <span class="org-rainbow-delimiters-depth-2">[</span>split-keys block<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">loop</span> <span class="org-rainbow-delimiters-depth-3">[</span>b block
         r-keys split-keys
         n 1<span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-rainbow-delimiters-depth-5">[</span>round-key &amp; other-keys<span class="org-rainbow-delimiters-depth-5">]</span> r-keys<span class="org-rainbow-delimiters-depth-4">]</span>
      <span class="org-rainbow-delimiters-depth-4">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-5">(</span>&lt; n 10<span class="org-rainbow-delimiters-depth-5">)</span>
        <span class="org-rainbow-delimiters-depth-5">(</span><span class="org-keyword">recur</span> <span class="org-rainbow-delimiters-depth-6">(</span>normal-round round-key b<span class="org-rainbow-delimiters-depth-6">)</span>
               other-keys
               <span class="org-rainbow-delimiters-depth-6">(</span>inc n<span class="org-rainbow-delimiters-depth-6">)</span><span class="org-rainbow-delimiters-depth-5">)</span>
        b<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defn</span> <span class="org-function-name">aes-128-encrypt-block</span> <span class="org-rainbow-delimiters-depth-2">[</span>key block<span class="org-rainbow-delimiters-depth-2">]</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">let</span> <span class="org-rainbow-delimiters-depth-3">[</span>split-keys <span class="org-rainbow-delimiters-depth-4">(</span>key-expansion key<span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-keyword">-&gt;&gt;</span> block
         <span class="org-rainbow-delimiters-depth-4">(</span>map bit-xor <span class="org-rainbow-delimiters-depth-5">(</span>first split-keys<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>apply-normal-rounds <span class="org-rainbow-delimiters-depth-5">(</span>rest split-keys<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span>
         <span class="org-rainbow-delimiters-depth-4">(</span>map s-box<span class="org-rainbow-delimiters-depth-4">)</span>
         shift-rows
         <span class="org-rainbow-delimiters-depth-4">(</span>map bit-xor <span class="org-rainbow-delimiters-depth-5">(</span>last split-keys<span class="org-rainbow-delimiters-depth-5">)</span><span class="org-rainbow-delimiters-depth-4">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Boom. Happy encrypting. Decryption is pretty straight forward, by the way, Iâ€™ll let you figure that out for yourself.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
